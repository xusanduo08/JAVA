#### 线程状态

1.新生状态：使用new关键字和`Thread`类或其子类建立一个线程对象后，该线程就处于新生状态，处于新生状态的线程有自己的内存空间，通过调用`start`方法进入就绪状态。

2.就绪状态：处于就绪状态的线程已经具备了运行条件，但还没有分配到CPU，处于线程就绪队列，等待系统为其分配CPU，当系统选定一个等待执行的`Thread`对象后，该对象就会从等待执行状态进入执行状态，系统挑选的动作称之为“CPU调度”。一旦获取CPU，线程就进入运行状态并自动调用自己的`run`方法

3.运行状态：在运行状态的线程执行自己的`run`方法中代码，直到调用其他方法而终止或等待某资源而阻塞或完成任务而死亡。如果在给定的时间片内没有执行结束，，就会被系统给换下来回到等待执行状态。

4.阻塞状态：处于运行状态的线程在某些情况下，如执行了`sleep`方法，或等待I/O设备等资源。在阻塞状态的线程不能进入就绪队列，__只有当引起阻塞的原因消除时，如睡眠时间已到，或等待的I/O设备空闲下来，线程便转入就绪状态，重新到就绪队列中排队等待__，被系统选中后从原来停止的位置开始继续运行。

5.死亡状态：正常死亡（线程体正常执行完毕）、线程被强制终止，如通过执行`stop`或`destory`方法来终止一个线程（不推荐使用这两个方法，前者会产生异常，后者是强制终止，不会释放锁）



##### `yield`、`join`、`sleep`

__`yield()`方法只是使当前线程重新回到可执行状态__，所以执行`yield()`的线程有可能在进入到可执行状态后马上又被执行。

`join()`方法会使当前线程等待调用`join()`方法的线程结束后才继续运行。

```java
package Thread;

public class Join  implements Runnable{
  public void run(){
    for(int i = 0; i< 100; i++){
      System.out.println("join 线程"+ i);
    }
  }

  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread(new Join());
    t.start();

    for(int i = 0; i < 100; i++){
      if(i == 50){
        t.join(); // main线程会等待t线程结束后再运行
      }
      System.out.println("main 输出" + i);
    }
  }
}

```

`sleep()`方法让当前正在执行的线程在指定时间内暂停执行，进入阻塞状态，不会释放“锁标志”


