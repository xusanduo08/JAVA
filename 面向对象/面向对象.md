**为什么面向对象**

对机器进行抽象，需要着重考虑计算机的结构，而非考虑问题本身。

而且这样做还需要在机器模型和实际问题模型之间建立一种联系，维护这种联系也需要很大的精力。

对机器建模的另一种方法是对实际问题进行建模。利用一些工具表达问题空间内的元素，这些元素以及它们在方案空间的表示物称作“对象”。

通过添加新的对象类型，程序可进行灵活的调整。

每个对象都有自己的状态，而且可要求它们进行特定的操作。

1. 多有东西都是对象，可将对象想象成一种新型变量。
2. 程序是一大堆对象的组合。
3. 每个对象都有自己的存储空间，可容纳其他对象。或者说，通过封装现有对象，可制作出新型对象。所以，程序中，对象可以达到任意高的高度。
4. 每个对象都有一种类型，每个对象都是某个类的实例。一个类最重要的特征是“能将什么消息发给它”。
5. 同一类所有对象都能接收相同的消息。



**如果操作对象？**

每个对象仅能接收特定的请求，我们向对象发出的请求是通过它的“接口”定义的，对象的“类型”或“类”则规定了它的接口形式。

**隐藏**

为什么要隐藏？隐藏之后，客户程序员就不能接触和改变那些细节，所以原创者不用担心自己的作品会受到非法修改，可确保它们不会对其他人造成影响。

“接口”规定了可对一个特定的对象发出哪些请求。

**如何重复使用？**

创建一个成员对象：将一个对象置入一个新的类。新类可由任意数量和类型的其他对象构成----**组织**---在现有类的基础上组织一个新类。（可类比“一辆车包含了一个变速箱”）

新建类的时候，首相应当考虑“组织”对象：这样做显得更加简单和灵活。利用对象的组织，我们的设计可以保持清爽。

**继承**

继承生成新类，这个新类不仅包含了现有类型的所有成员，它也复制了基础类的接口。因此，可向基础类的对象发送的所有消息亦可原样发送给衍生类的对象。

由于基础类和衍生类具有相同的接口，所以那个接口必须进行特殊设计。两种方法：

1. 为衍生类添加新函数
2. 改善基础类：改善基础类的一个现有函数的行为

类似关系：新类型拥有旧类型的接口，但也包含了其他函数，所以不能说它们完全等价。

**多型**

继承会以一系列类收场，所有类都建立在统一的接口基础上。

将衍生类的对象当做基础类的一个对象对待。

忽略类型的特定细节，只与基础类打交道。这样，代码就可与类型信息分开，所以更易编写，也更易理解。

**动态绑定**

多态

**抽象基础类和接口**

abstract。基础类只为自己的衍生类提供接口，不想其他任何人实际创建基础类的一个对象，只对上溯造型使用它。

抽象方法只能在抽象类里实现，继承了一个类后，这个抽象方法就必须实现，否则继承的类也会变成“抽象”类。

interface更加抽象。完全禁止了所有的函数定义。

**集合**

解决特定问题的新型对象，容纳了指向其他对象的句柄。在适当的时候，集合会自动扩充，以便适应我们在其中放入的任何东西。所以我们事先并不知道要在一个集合里容下多少东西。

集、队列、散列表、树、堆栈等。

**继续器（Iterator）**

**单根结构**

所有类最终都应从单独一个基础类继承----Object

**解决错误**

**多线程**









